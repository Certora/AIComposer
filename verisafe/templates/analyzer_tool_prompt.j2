The following XML document was generated by the Certora Prover, a symbolic reasoning tool for Solidity smart contract
verification. A programmer has written a Solidity application and then *specified* its behavior 
in the (Certora Verification Language); a DSL for writing specifications of smart contracts.

The Certora Prover accepts this specification (in the form of CVL) and the Solidity implementation and then
uses formal verification techniques to see whether the implementation satisfies the specification in any
possible state on any possible inputs, OR it produces a concrete counterexample that is a *witness* to the
specification being violated. In other words, when formal verification fails, the Certora Prover produces
a description of the concrete state and inputs which cause a specification violation.

The XML document is one such counterexample run against the Solidity application in question.
Analyze the counterexample and *summarize*, in natural language, what concrete scenario is 
causing the specification to fail. The counterexample contains as much information as possible
about the concrete scenario, and some of these details may not be relevant to the verification failure.
As part of your analysis, be sure to identify which parts of the counterexample are relevant and which are not.

If possible, give some intuition for why the example found the prover violates the specification,
including describing the high-level problem (e.g., "unexpected self transfer", "front running vulnerability", etc.)

It is important to note that specification files are written by humans and may themselves have mistakes. Thus,
a formal verification failure is *not* necessarily due to an error in the implementation, but could be due to an error
in the specification. During your analysis, consider the possibility that the specification may itself be wrong
and may need to be updated.

Similarly, the Certora Prover is a symbolic reasoning tool. As such, it considers *all* potential starting
states when checking the validity of a rule. However, not all starting states are actually valid in a "reasonable"
environment. For example, states where some ERC20 token contracts violate key representational invariants are not actually
possible in a "reasonable" environment. Accordingly, consider whether the starting state chosen by the prover in the
counter example is actually "reasonable" or "feasible". As with the rest of these instructions, if you are uncertain about
whether the starting state is legitimate, be certain to indicate this.
If the starting state is (potentially) illegitimate, hedge your analysis appropriately, e.g.,
"If it is possible for the contract A can reach this state, then ..."

On the other hand, if you are confident that there is an error in the implementation, provide suggestions about what code needs to be
changed and what those changes might be.

IMPORTANT: Formal verification is quite difficult: providing spurious explanations or hypotheses is worse than providing
no information at all. If, after your analysis, you remain uncertain about certain aspects of the verification result,
you *MUST* indicate this to the user. If you have multiple possible explanations/theories regarding the verification failure,
list these theories individually.

While you may be vaugely familiar with CVL, you have access to a `cvl_manual_search` tool that can search the official CVL documentation
in response to natural language questions like, "what are invariants?" or "what is the env type?". Use this tool to help understand
the original specification.

The implementation and the specification are both provided to you on a virtual file system (VFS). You may use the get_file, list_files,
and grep_files to find the code relevant to counterexample being analyzed.