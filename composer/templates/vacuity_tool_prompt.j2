Below, you are provided with an **unsat core** generated by the Certora Prover
when analyzing a CVL rule (or invariant) that failed verification due to vacuity
- meaning the rule's assertion is unreachable. The unsat core was extracted from
the SMT encoding and then mapped to the TAC program commands: assumes,
assignments, and assertions.

## **Understanding the Unsat Core Structure**

The unsat core (UC) is provided in a structured text format with the following sections:

### **TAC Blocks and Commands**
Each TAC block is presented with:
- **Block header**: `BlockID call:FunctionName` (e.g., `18_0_0_1_0_0 call:Bank.withdraw`)
- **Commands in the block**: Each command shows:
  1. **UC Classification**: `[in UC]` or `[context]` - **THIS IS THE MOST CRUCIAL INFORMATION**
  2. **Command number**: Sequential number within the block
  3. **Command type and content**: The actual TAC command (e.g., `ASSERT`, `ASSUME`, `B125:bool := Lt(...)`)
  4. **Source mapping** (optional): Location in `.spec` or `.sol` files in brackets
  5. **Meta information**: Additional context under the command (e.g., `cvl.exp`, `tac.transfers.balance`)

### **Key Insights**
- **`[in UC]` commands**: These are the problematic constraints causing unsatisfiability
- **`[context]` commands**: Provide context and help map TAC commands to source code
- **Annotation commands** not in UC often contextualize the UC commands and reveal prover settings (linking, dispatching)
- **Block relationships**: Show execution flow and control dependencies

### **CFG Info Section**
At the end, you will find info about edges between TAC blocks, in this format:
  CFG INFO:
    Edges(compacted to UC blocks):
      TARGET <- {SOURCE1,SOURCE2}
      TARGET <- {SOURCE3}

  Key Points:
  1. Each line shows: one TARGET block and the set of SOURCE blocks that have a
  direct edge to TARGET in the UC-compacted graph
  2. the UC-compacted graph originates from the original CFG graph by removing intermediate non-UC blocks
  3. the set of edges **is not** a transitive closure; it shows only the direct
  neighbours in the compacted graph

  Example:
  520_0_0_125_0_4484 <- {753_0_0_125_0_0,755_0_0_125_0_0}
  = Block 520... has direct incoming edges from blocks 753... and 755... in the compacted graph

## **Additional Resources Available**

You have access to:
- **Full TAC file**: The complete TAC program (not just unsat core subset) at `outputs/PresolverRule-{rule}-{method}.tac`
- **Source files**: Solidity contracts and CVL specifications via file system tools
- **CVL manual**: For understanding specification semantics

## **Your Analysis Approach**

### 1. **Identify the Problematic Constraints**
- Focus on commands marked `[in UC]` - these are the unsatisfiable constraints
- Examine the sequence and relationships between `[in UC]` commands
- Use surrounding `[context]` commands for context and source mapping

### 2. **Trace Execution Flows**
- Follow the CFG edges to understand how execution reaches the unsat core
- Identify the critical path through blocks containing `[in UC]` commands
- The "latest" (w.r.t. the graph structure) commands forms a cut in the graph,
blocking all execution traces, and corresponding paths, that lead to the rule
assertion(s). Hence, this cut represents the "borderline" where the "execution"
of the program & rule gets stuck.
- Use surrounding `[context]` commands for context and source mapping

### 3. **Map to Source Code**
- Use source mappings in brackets (e.g., `(Bank.spec:71:5)`) and the `[context]`
commands to locate relevant code
- Read the actual Solidity and CVL files to understand the high-level intent
- Connect TAC-level constraints to specification requirements

### 4. **Root Cause Diagnosis**
Determine if the vacuity stems from:
- **Specification issues**: Overly restrictive CVL rules, unreachable assertions
- **Logical expression evaluation problems**: The prover compiles logical expressions into single TAC blocks and evaluates ALL subexpressions. Look for:
  - Implications where the consequent contains operations that cause `assume false` or `require false`
  - When `assume/require false` appears in the RHS of an implication, it gets compiled into the same TAC block as the LHS
  - This makes the entire TAC block infeasible, causing vacuity even when the LHS would be false
  - **Key insight**: The problem is the single TAC block compilation, not short-circuit evaluation
- **Implementation conflicts**: Solidity code that prevents the rule scenario
- **Prover configuration**: Common issues include:
  - Insufficient loop unrolling (`loop_iter` flag)
  - Insufficient hashing bounds (`hashing_length_bound` flag)
  - Missing dynamic contract support (`dynamic_bound`, `dynamic_dispatch` flags)
  - Contract linking conflicts: Look for `MinContractAddrCheck` constraints indicating prover-generated non-zero address assumptions for linked contracts
  - Dispatcher setup problems: `DISPATCHER` summaries creating conflicting contract instance assumptions

### 5. **Actionable Solutions**
Provide specific recommendations:
- **CVL rule modifications with exact syntax**:
  - For logical expression issues: Extract problematic implications into CVL functions using explicit `if-then-else` control flow
  - **Cannot use if-then-else directly in invariants** - must use helper functions
  - Example transformation for invariants:
    ```cvl
    // Instead of: (A && B) => problematicExpression()
    function helperFunction() returns bool {
      if (A && B) {
        return problematicExpression();
      } else {
        return true;
      }
    }
    invariant myInvariant() helperFunction()
    ```
  - This creates separate TAC blocks for different execution paths, preventing `assume false` from making the entire block infeasible
- **Prover configuration adjustments**:
  - **Dynamic contract creation**: If you see contract creation commands with
  dispatcher failures, use `"dynamic_bound": N` and `"dynamic_dispatch": true`
  flags - *do NOT* modify DISPATCHER settings **in this case**
  - **Loop iteration bounds**: For `loop_iter` issues, suggest both a minimal
  non-vacuous bound and a safe recommended bound (possibly larger than the
  minimal one but not too inflated). Explain the
  rationale for each value.
  - **Hashing Bounds**: For `hashing_length_bound` issues, suggest both a
  minimal non-vacuous and a safe recommended bound.
  - **Contract linking issues**: Review `--link` configuration if `MinContractAddrCheck` appears in unsat core
- Implementation changes if needed
- Reference the documentation database for additional prover configuration
options

**DO NOT SUGGEST USING FLAGS THAT ARE NOT LISTED IN THE PROMPT NOR IN THE DOCUMENTATION**

**Strategy**: Focus on the `[in UC]` commands to identify the problematic constraints, use the CFG edges to understand execution flows, and leverage source mappings and context from `[context]` commands to understand why these constraints cannot be satisfied together.
