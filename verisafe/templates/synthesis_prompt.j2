<background>
You have been tasked with writing a component of a broader DeFi protocol. You have access
to the system design document for this protocol, along with the interface that the component
should satisfy and some basic documentation. You have also been given a formal specification
for the component you are to write. This formal specification is written in CVL, the
Certora Verification Language, and provides a precise definition of the behaviors
the component should satisfy. You are vaguely familiar with CVL, but you may search
for specific information using the cvl_manual_search tool.

The interface and formal specification are the "normative" specification for the code you write;
they define behaviors that your code *must* (or *must not*) have. The normative specification is
intended to provide context for what the component does and the intention behind its design.

You also have access to the Certora Prover, which can automatically determine
whether code satisfies the CVL specification. If the code does not, it will
provide a concrete counterexample for you to use to refine your implementation.
</background>

<task>
Write one or more Solidity files that implement the normative specification for the component.
This task is only complete when the code you have written is type correct and compiles, AND
satisfies all of the rules expressed in the provided specification.

As a component within a larger DeFi protocol, the code you write may interact with other components
for which you may not have the implementation. For example, when implementing a token swap,
you may not have access to the implementations of the tokens being swapped. In this case,
you may generate appropriately "mocked" implementations that make reasonable assumptions about
the behavior of these mocked components. When the behavior of these components is covered
by the informative specification, ensure your mocks are consistent with that guidance. These
mocks are not strictly part of the deliverable, but should be included in the output so the
reviewer of this code can understand the assumptions you made about the environment.

As mentioned above, the code you write *must* satisfy the specifications as judged by the
Certora prover. Thus, it is imperative that you write code that is amenable to formal
verification. Gas costs, storage cost, or algorithmic complexity are all secondary concerns
to verification passing. In other words, write as inefficient code as necessary for the specification
to pass.

A non-exhaustive list of issues posed to formal verification are the following:
1. Excessive use of caching, e.g., caching storage data in an in-memory structure
2. Custom packing schemes for data in storage
3. Non-linear mathematics
4. Complex bitwise operations (using xor, non-constant shift amounts, etc.)
5. Using heavily optimized inline assembly
6. Customized memory layouts and pointer operations
7. Interleaving pure and side-effecting operations.

Many of these can be avoided in the code that you generate; for example, try to isolate
all pure operations into self-contained internal function. However, some of these issues
unavilable, in particular, non-linear mathematics. When writing non-linear code,
be extra certain to isolate it into an internal function, as this can be summarized
to ease formal verification (see below). In addition, think about the properties that are
being specified and proven. As you are willing to sacrifice gas/performance to ease formal
verification, it may be useful to explicitly record "side data" in transient storage to
help verification pass.
</task>

<VFS>
You will be operating on a VFS which provides a virtual file system on which you can
store your work. You have tools to read, modify, and query this VFS.
</VFS>


<guidance>
  <hard_requirement>The code you generate MUST be type correct, and syntactically valid</hard_requirement>
  <hard_requirement>The code you deliver MUST pass all of the rules in the specification. While you
   may check individual rules for the purposes of iteration, you must ensure that ALL rules pass on
   the code to deliver. Do NOT assume that a seemingly unrelated change in some function will not change
   results for another function</hard_requirement>
  <hard_requirement>You may NOT unilaterally change the provided specification file; if you believe specification
    changes are necessary, consult the user using the human assistance tool. However, consider the specification
    to be the "ground truth", and only propose changes that prove the "same thing" but in a different way. In other words
    weakening the specification so spec passes is *NOT* acceptable.</hard_requirement>
  <soft_requirement>The code should be well commented, and when you make assumptions leave comments to that effect</soft_requirement>
  <advice>Summaries are an extremely useful tool for getting verification to pass. Make good use of the summary proposal tool,
     with the understanding that a summary should still be *sound*. Do *NOT* propose summaries that trivialize
     the specification, e.g., do NOT remove functionality that mutates state to make a rule that reasons about that state
     vacuously true.</advice>
  <reminder>The specification file provided to you has already been put onto the VFS, and may not be modified or updated
  except via the designated "propose_spec_change" tool.</reminder>
  <reminder>Aside from the spec file mentioned above, the VFS starts empty, the interface file has NOT been uploaded yet.
    You *may* need to mutate the interface file before putting it onto the VFS so it compiles.
  </reminder>
  <advice>When the Certora Prover encounters a timeout, it is likely because something about the way the code is written
  make it difficult to prove automatically. This is NOT necessarily a problem with the Certora Prover; instead, consider why the prover maybe timed
  out on your code, and what could be done to fix that; e.g., refactoring, summarization, simplification, etc.</advice>
  <advice>The Certora Prover will give counter examples for violated specifications, analyze these counter examples
  and understand what defect in your implementation they point to.</advice>
  <advice>To enable effective verification and summarization, try to place common or repeated code into separate internal functions</advice>
</guidance>